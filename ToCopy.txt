====OLD components.css====
/* TOOLS GRID */
.tools-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
}

/* CARD */
.tool-card {
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  padding: 1.5rem;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

/* BUTTONS */
.btn {
  background: var(--primary);
  color: #fff;
  padding: 0.5rem 1rem;
  border-radius: 8px;
  text-decoration: none;
}

.card-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 1rem;
}

.fav-btn {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 1.1rem;
}

.fav-btn {
  font-size: 1.3rem;
  color: gold;
}

.fav-btn.active {
  transform: scale(1.1);
}

.tool-search {
  margin-bottom: 2.5rem;
  text-align: center;
}

.tool-search input {
  width: 100%;
  max-width: 450px;
  padding: 0.8rem 1rem 0.8rem 2.8rem; /* Extra left padding to make room for the icon */
  border-radius: 12px;
  border: 1px solid var(--border-color);
  background-color: var(--card-bg);
  color: var(--text-color);
  font-size: 1rem;
  
  /* Adding the magnifying glass icon as a background image */
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%2394a3b8'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'%3E%3C/path%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: 12px center;
  background-size: 20px;
  
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

/* Interaction States */
.tool-search input:hover {
  border-color: #3b82f6;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

.tool-search input:focus {
  outline: none;
  background-color: #ffffff;
  border-color: #3b82f6;
  box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.15), 0 4px 12px rgba(0, 0, 0, 0.08);
  max-width: 480px; /* Slight width expansion for a dynamic feel */
}

/* Dark Mode adjustment if needed */
@media (prefers-color-scheme: dark) {
  .tool-search input:focus {
    background-color: var(--card-bg); /* Keep it dark in dark mode */
  }
}

/* Filter & Tag Styles */
.tool-filters {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  flex-wrap: wrap;
  margin-bottom: 1rem;
}

.tool-filters button {
  padding: 0.4rem 0.9rem;
  border-radius: 20px;
  border: 1px solid var(--border-color);
  background: var(--card-bg);
  cursor: pointer;
}

.tool-filters button.active {
  background: var(--primary);
  color: #fff;
}

.tags {
  margin: 0.5rem 0;
}

.tags span {
  font-size: 0.75rem;
  margin-right: 0.3rem;
  color: var(--primary);
}


====OLD tools.css====
.tool-wrapper {
  max-width: 500px;
  margin: auto;
}

.tool-desc {
  margin-bottom: 1.5rem;
  color: #64748b;
}

.tool-box {
  display: grid;
  gap: 1rem;
}

.tool-box input,
.tool-box select {
  padding: 0.7rem;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background: var(--card-bg);
  color: var(--text-color);
}

.result {
  margin-top: 1rem;
  font-weight: bold;
}

.markdown-tool {
  max-width: 100%;
}

.markdown-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
}

.markdown-grid textarea {
  min-height: 300px;
  padding: 1rem;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background: var(--card-bg);
  color: var(--text-color);
  resize: vertical;
}

.preview-box {
  min-height: 300px;
  padding: 1rem;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background: var(--card-bg);
  overflow-y: auto;
}

/* Mobile */
@media (max-width: 768px) {
  .markdown-grid {
    grid-template-columns: 1fr;
  }
}

.qr-result {
  margin: 1rem auto;
  text-align: center;
}

====OLD color-conver.js====
const hexInput = document.getElementById("hex");
const rgbInput = document.getElementById("rgb");
const hslInput = document.getElementById("hsl");
const preview = document.getElementById("preview");
const status = document.getElementById("status");

// Added from image: reference to the palette grid
const paletteGrid = document.getElementById("paletteGrid");

function setStatus(msg, ok = true) {
  status.textContent = msg;
  status.style.color = ok ? "green" : "red";
}

// Added from image: Function to generate the palette boxes
function generatePalette(hex) {
  paletteGrid.innerHTML = "";
  const rgb = hexToRgb(hex.replace("#", ""));

  if (!rgb) return;

  for (let i = -4; i <= 4; i++) {
    const factor = i * 15;
    const r = Math.min(255, Math.max(0, rgb.r + factor));
    const g = Math.min(255, Math.max(0, rgb.g + factor));
    const b = Math.min(255, Math.max(0, rgb.b + factor));

    const shade = rgbToHex(r, g, b);
    const box = document.createElement("div");

    box.className = "palette-color";
    box.style.background = shade;
    box.title = shade;
    box.onclick = () => {
      navigator.clipboard.writeText(shade);
      setStatus("Shade Copied!");
      setTimeout(() => setStatus("✓"), 1000);
    };

    paletteGrid.appendChild(box);
  }
}

function hexToRgb(hex) {
  hex = hex.replace("#", "");
  if (hex.length !== 6) return null;
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  return { r, g, b };
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => x.toString(16).padStart(2, "0"))
      .join("")
  );
}

function rgbToHsl(r, g, b) {
  r /= 255; g /= 255; b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h *= 60;
  }
  return {
    h: Math.round(h),
    s: Math.round(s * 100),
    l: Math.round(l * 100)
  };
}

function hslToRgb(h, s, l) {
  s /= 100; l /= 100;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs((h / 60) % 2 - 1));
  const m = l - c / 2;
  let r = 0, g = 0, b = 0;

  if (h < 60) [r, g, b] = [c, x, 0];
  else if (h < 120) [r, g, b] = [x, c, 0];
  else if (h < 180) [r, g, b] = [0, c, x];
  else if (h < 240) [r, g, b] = [0, x, c];
  else if (h < 300) [r, g, b] = [x, 0, c];
  else [r, g, b] = [c, 0, x];

  return {
    r: Math.round((r + m) * 255),
    g: Math.round((g + m) * 255),
    b: Math.round((b + m) * 255)
  };
}

function updatePreview(hex) {
  preview.style.background = hex;
}

hexInput.addEventListener("input", () => {
  const hexValue = hexInput.value;
  const rgb = hexToRgb(hexValue);
  if (!rgb) return setStatus("Invalid HEX", false);

  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
  rgbInput.value = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
  hslInput.value = `${hsl.h}, ${hsl.s}%, ${hsl.l}%`;
  updatePreview(hexValue);
  generatePalette(hexValue);
  setStatus("✓");
});

rgbInput.addEventListener("input", () => {
  const parts = rgbInput.value.split(",").map(Number);
  if (parts.length !== 3) return;

  const [r, g, b] = parts;
  if ([r, g, b].some(n => n < 0 || n > 255)) return;

  const hex = rgbToHex(r, g, b);
  const hsl = rgbToHsl(r, g, b);

  hexInput.value = hex;
  hslInput.value = `${hsl.h}, ${hsl.s}%, ${hsl.l}%`;
  updatePreview(hex);
  generatePalette(hex);
  setStatus("✓");
});

hslInput.addEventListener("input", () => {
  const parts = hslInput.value.replace(/%/g, "").split(",").map(Number);
  if (parts.length !== 3) return;

  const [h, s, l] = parts;
  if (h < 0 || h > 360 || s < 0 || s > 100 || l < 0 || l > 100) return;

  const rgb = hslToRgb(h, s, l);
  const hex = rgbToHex(rgb.r, rgb.g, rgb.b);

  hexInput.value = hex;
  rgbInput.value = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
  updatePreview(hex);
  generatePalette(hex);
  setStatus("✓");
});

// --- NEW COPY LOGIC INTEGRATED HERE ---
document.getElementById("copyHex").onclick = () => {
  navigator.clipboard.writeText(hexInput.value);
  setStatus("HEX Copied!");
  setTimeout(() => setStatus("✓"), 1000);
};

document.getElementById("copyRgb").onclick = () => {
  navigator.clipboard.writeText(`rgb(${rgbInput.value})`);
  setStatus("RGB Copied!");
  setTimeout(() => setStatus("✓"), 1000);
};

document.getElementById("copyHsl").onclick = () => {
  navigator.clipboard.writeText(`hsl(${hslInput.value})`);
  setStatus("HSL Copied!");
  setTimeout(() => setStatus("✓"), 1000);
};
// --------------------------------------

// Slider Logic
const rRange = document.getElementById("rRange");
const gRange = document.getElementById("gRange");
const bRange = document.getElementById("bRange");

const hRange = document.getElementById("hRange");
const sRange = document.getElementById("sRange");
const lRange = document.getElementById("lRange");

function syncRgbSliders(r, g, b) {
  rRange.value = r;
  gRange.value = g;
  bRange.value = b;
}

function syncHslSliders(h, s, l) {
  hRange.value = h;
  sRange.value = s;
  lRange.value = l;
}

[rRange, gRange, bRange].forEach((slider) => {
  slider.oninput = () => {
    const r = +rRange.value;
    const g = +gRange.value;
    const b = +bRange.value;

    const hex = rgbToHex(r, g, b);
    const hsl = rgbToHsl(r, g, b);

    hexInput.value = hex;
    rgbInput.value = `${r}, ${g}, ${b}`;
    hslInput.value = `${hsl.h}, ${hsl.s}%, ${hsl.l}%`;
    syncHslSliders(hsl.h, hsl.s, hsl.l);
    updatePreview(hex);
    generatePalette(hex);
  };
});

[hRange, sRange, lRange].forEach((slider) => {
  slider.oninput = () => {
    const h = +hRange.value;
    const s = +sRange.value;
    const l = +lRange.value;

    const rgb = hslToRgb(h, s, l);
    const hex = rgbToHex(rgb.r, rgb.g, rgb.b);

    hexInput.value = hex;
    rgbInput.value = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
    hslInput.value = `${h}, ${s}%, ${l}%`;
    syncRgbSliders(rgb.r, rgb.g, rgb.b);
    updatePreview(hex);
    generatePalette(hex);
  };
});